// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by hack/docgen tool. DO NOT EDIT.

package block

import (
	"github.com/siderolabs/talos/pkg/machinery/config/encoder"
)

func (EncryptionSpec) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionSpec",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionSpec represents volume encryption settings." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionSpec represents volume encryption settings.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "SwapVolumeConfigV1Alpha1",
				FieldName: "encryption",
			},
			{
				TypeName:  "UserVolumeConfigV1Alpha1",
				FieldName: "encryption",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "provider",
				Type:        "EncryptionProviderType",
				Note:        "",
				Description: "Encryption provider to use for the encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Encryption provider to use for the encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"luks2",
				},
			},
			{
				Name:        "keys",
				Type:        "[]EncryptionKey",
				Note:        "",
				Description: "Defines the encryption keys generation and storage method.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the encryption keys generation and storage method." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "cipher",
				Type:        "string",
				Note:        "",
				Description: "Cipher to use for the encryption. Depends on the encryption provider.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Cipher to use for the encryption. Depends on the encryption provider." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"aes-xts-plain64",
					"xchacha12,aes-adiantum-plain64",
					"xchacha20,aes-adiantum-plain64",
				},
			},
			{
				Name:        "keySize",
				Type:        "uint",
				Note:        "",
				Description: "Defines the encryption key length.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the encryption key length." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "blockSize",
				Type:        "uint64",
				Note:        "",
				Description: "Defines the encryption sector size.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the encryption sector size." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "options",
				Type:        "[]string",
				Note:        "",
				Description: "Additional --perf parameters for the LUKS2 encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Additional --perf parameters for the LUKS2 encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"no_read_workqueue",
					"no_write_workqueue",
					"same_cpu_crypt",
				},
			},
		},
	}

	doc.AddExample("", exampleEncryptionSpec())

	doc.Fields[2].AddExample("", "aes-xts-plain64")
	doc.Fields[4].AddExample("", 4096)
	doc.Fields[5].AddExample("", []string{"no_read_workqueue", "no_write_workqueue"})

	return doc
}

func (EncryptionKey) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKey",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKey represents configuration for disk encryption key." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKey represents configuration for disk encryption key.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionSpec",
				FieldName: "keys",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "slot",
				Type:        "int",
				Note:        "",
				Description: "Key slot number for LUKS2 encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Key slot number for LUKS2 encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "static",
				Type:        "EncryptionKeyStatic",
				Note:        "",
				Description: "Key which value is stored in the configuration file.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Key which value is stored in the configuration file." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "nodeID",
				Type:        "EncryptionKeyNodeID",
				Note:        "",
				Description: "Deterministically generated key from the node UUID and PartitionLabel.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Deterministically generated key from the node UUID and PartitionLabel." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "kms",
				Type:        "EncryptionKeyKMS",
				Note:        "",
				Description: "KMS managed encryption key.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KMS managed encryption key." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "tpm",
				Type:        "EncryptionKeyTPM",
				Note:        "",
				Description: "Enable TPM based disk encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable TPM based disk encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (EncryptionKeyStatic) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyStatic",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyStatic represents throw away key type." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyStatic represents throw away key type.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "static",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "passphrase",
				Type:        "string",
				Note:        "",
				Description: "Defines the static passphrase value.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the static passphrase value." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (EncryptionKeyKMS) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyKMS",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyKMS represents a key that is generated and then sealed/unsealed by the KMS server." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyKMS represents a key that is generated and then sealed/unsealed by the KMS server.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "kms",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "endpoint",
				Type:        "string",
				Note:        "",
				Description: "KMS endpoint to Seal/Unseal the key.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KMS endpoint to Seal/Unseal the key." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", exampleKMSKey())

	return doc
}

func (EncryptionKeyTPM) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyTPM",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyTPM represents a key that is generated and then sealed/unsealed by the TPM." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyTPM represents a key that is generated and then sealed/unsealed by the TPM.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "tpm",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "checkSecurebootStatusOnEnroll",
				Type:        "bool",
				Note:        "",
				Description: "Check that Secureboot is enabled in the EFI firmware.\nIf Secureboot is not enabled, the enrollment of the key will fail. As the TPM key is anyways bound to the value of PCR 7, changing Secureboot status or configuration after the initial enrollment will make the key unusable.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Check that Secureboot is enabled in the EFI firmware." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (EncryptionKeyNodeID) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyNodeID",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyNodeID represents deterministically generated key from the node UUID and PartitionLabel." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyNodeID represents deterministically generated key from the node UUID and PartitionLabel.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "nodeID",
			},
		},
		Fields: []encoder.Doc{},
	}

	return doc
}

func (SwapVolumeConfigV1Alpha1) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "SwapVolumeConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "SwapVolumeConfig is a disk swap volume configuration document." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "SwapVolumeConfig is a disk swap volume configuration document.\nSwap volume is automatically allocated as a partition on the specified disk\nand activated as swap, removing a swap volume deactivates swap.\nThe partition label is automatically generated as `s-<name>`.\n",
		Fields: []encoder.Doc{
			{},
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Name of the volume.\n\nName might be between 1 and 34 characters long and can only contain:\nlowercase and uppercase ASCII letters, digits, and hyphens.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Name of the volume." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "provisioning",
				Type:        "ProvisioningSpec",
				Note:        "",
				Description: "The provisioning describes how the volume is provisioned.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The provisioning describes how the volume is provisioned." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "encryption",
				Type:        "EncryptionSpec",
				Note:        "",
				Description: "The encryption describes how the volume is encrypted.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The encryption describes how the volume is encrypted." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", exampleSwapVolumeConfigV1Alpha1())

	return doc
}

func (UserVolumeConfigV1Alpha1) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "UserVolumeConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "UserVolumeConfig is a user volume configuration document." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "UserVolumeConfig is a user volume configuration document.\nUser volume is automatically allocated as a partition on the specified disk\nand mounted under `/var/mnt/<name>`.\nThe partition label is automatically generated as `u-<name>`.\n",
		Fields: []encoder.Doc{
			{},
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Name of the volume.\n\nName might be between 1 and 34 characters long and can only contain:\nlowercase and uppercase ASCII letters, digits, and hyphens.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Name of the volume." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "provisioning",
				Type:        "ProvisioningSpec",
				Note:        "",
				Description: "The provisioning describes how the volume is provisioned.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The provisioning describes how the volume is provisioned." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "filesystem",
				Type:        "FilesystemSpec",
				Note:        "",
				Description: "The filesystem describes how the volume is formatted.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The filesystem describes how the volume is formatted." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "encryption",
				Type:        "EncryptionSpec",
				Note:        "",
				Description: "The encryption describes how the volume is encrypted.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The encryption describes how the volume is encrypted." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", exampleUserVolumeConfigV1Alpha1())

	return doc
}

func (FilesystemSpec) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "FilesystemSpec",
		Comments:    [3]string{"" /* encoder.HeadComment */, "FilesystemSpec configures the filesystem for the volume." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "FilesystemSpec configures the filesystem for the volume.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "UserVolumeConfigV1Alpha1",
				FieldName: "filesystem",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "type",
				Type:        "FilesystemType",
				Note:        "",
				Description: "Filesystem type. Default is `xfs`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Filesystem type. Default is `xfs`." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"ext4",
					"xfs",
				},
			},
		},
	}

	return doc
}

func (VolumeConfigV1Alpha1) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "VolumeConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "VolumeConfig is a system volume configuration document." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "VolumeConfig is a system volume configuration document.\nNote: at the moment, only `EPHEMERAL` and `IMAGE-CACHE` system volumes are supported.\n",
		Fields: []encoder.Doc{
			{},
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Name of the volume.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Name of the volume." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "provisioning",
				Type:        "ProvisioningSpec",
				Note:        "",
				Description: "The provisioning describes how the volume is provisioned.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The provisioning describes how the volume is provisioned." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", exampleVolumeConfigEphemeralV1Alpha1())

	return doc
}

func (ProvisioningSpec) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ProvisioningSpec",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ProvisioningSpec describes how the volume is provisioned." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ProvisioningSpec describes how the volume is provisioned.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "SwapVolumeConfigV1Alpha1",
				FieldName: "provisioning",
			},
			{
				TypeName:  "UserVolumeConfigV1Alpha1",
				FieldName: "provisioning",
			},
			{
				TypeName:  "VolumeConfigV1Alpha1",
				FieldName: "provisioning",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "diskSelector",
				Type:        "DiskSelector",
				Note:        "",
				Description: "The disk selector expression.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The disk selector expression." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "grow",
				Type:        "bool",
				Note:        "",
				Description: "Should the volume grow to the size of the disk (if possible).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Should the volume grow to the size of the disk (if possible)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "minSize",
				Type:        "ByteSize",
				Note:        "",
				Description: "The minimum size of the volume.\n\nSize is specified in bytes, but can be expressed in human readable format, e.g. 100MB.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The minimum size of the volume." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "maxSize",
				Type:        "ByteSize",
				Note:        "",
				Description: "The maximum size of the volume, if not specified the volume can grow to the size of the\ndisk.\n\nSize is specified in bytes, but can be expressed in human readable format, e.g. 100MB.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The maximum size of the volume, if not specified the volume can grow to the size of the" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[2].AddExample("", "2.5GiB")
	doc.Fields[3].AddExample("", "50GiB")

	return doc
}

func (DiskSelector) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "DiskSelector",
		Comments:    [3]string{"" /* encoder.HeadComment */, "DiskSelector selects a disk for the volume." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "DiskSelector selects a disk for the volume.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ProvisioningSpec",
				FieldName: "diskSelector",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "match",
				Type:        "Expression",
				Note:        "",
				Description: "The Common Expression Language (CEL) expression to match the disk.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The Common Expression Language (CEL) expression to match the disk." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[0].AddExample("match disks with size between 120GB and 1TB", exampleDiskSelector1())
	doc.Fields[0].AddExample("match SATA disks that are not rotational and not system disks", exampleDiskSelector2())

	return doc
}

// GetFileDoc returns documentation for the file block_doc.go.
func GetFileDoc() *encoder.FileDoc {
	return &encoder.FileDoc{
		Name:        "block",
		Description: "Package block provides block device and volume configuration documents.\n",
		Structs: []*encoder.Doc{
			EncryptionSpec{}.Doc(),
			EncryptionKey{}.Doc(),
			EncryptionKeyStatic{}.Doc(),
			EncryptionKeyKMS{}.Doc(),
			EncryptionKeyTPM{}.Doc(),
			EncryptionKeyNodeID{}.Doc(),
			SwapVolumeConfigV1Alpha1{}.Doc(),
			UserVolumeConfigV1Alpha1{}.Doc(),
			FilesystemSpec{}.Doc(),
			VolumeConfigV1Alpha1{}.Doc(),
			ProvisioningSpec{}.Doc(),
			DiskSelector{}.Doc(),
		},
	}
}
